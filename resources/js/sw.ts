// Service Worker for PWA Sync Functionality
import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare let self: ServiceWorkerGlobalScope;

// Take control of all pages immediately
clientsClaim();

// Clean up outdated caches
cleanupOutdatedCaches();

// Precache all the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache strategy for API calls
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Cache strategy for static assets
registerRoute(
  ({ request }) => request.destination === 'style' ||
                   request.destination === 'script' ||
                   request.destination === 'image',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Background Sync for offline transactions
const SYNC_TAG = 'cashier-sync';
const SYNC_QUEUE_NAME = 'sync-queue';

// Background sync registration
self.addEventListener('sync', async (event) => {
  if (event.tag === SYNC_TAG) {
    event.waitUntil(syncOfflineData());
  }
});

// Sync offline data when connection is restored
async function syncOfflineData() {
  try {
    console.log('Starting background sync...');

    // Get pending sync data from IndexedDB
    const pendingTransactions = await getPendingSyncData();

    if (pendingTransactions.length === 0) {
      console.log('No pending transactions to sync');
      return;
    }

    // Send data to server
    const syncResult = await syncToServer(pendingTransactions);

    if (syncResult.success) {
      // Clear successful syncs from offline storage
      await clearSyncedData(syncResult.syncedIds);

      // Notify all clients about successful sync
      await notifyClients({
        type: 'SYNC_COMPLETE',
        data: {
          syncedCount: syncResult.syncedCount,
          message: 'Data synchronized successfully'
        }
      });
    }

  } catch (error) {
    console.error('Background sync failed:', error);

    // Notify clients about sync failure
    await notifyClients({
      type: 'SYNC_ERROR',
      data: {
        error: error.message,
        message: 'Sync failed, will retry later'
      }
    });
  }
}

// Get pending sync data from IndexedDB
async function getPendingSyncData(): Promise<any[]> {
  try {
    const db = await openSyncDB();
    const transaction = db.transaction(['pending_transactions'], 'readonly');
    const store = transaction.objectStore('pending_transactions');
    const request = store.getAll();

    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  } catch (error) {
    console.error('Failed to get pending sync data:', error);
    return [];
  }
}

// Sync data to server
async function syncToServer(transactions: any[]): Promise<any> {
  const response = await fetch('/api/transactions/sync', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    },
    body: JSON.stringify({ transactions }),
  });

  if (!response.ok) {
    throw new Error(`Sync failed: ${response.statusText}`);
  }

  const result = await response.json();

  return {
    success: result.status === 'success',
    syncedCount: result.summary?.success || 0,
    syncedIds: result.results
      ?.filter((r: any) => r.status === 'success')
      ?.map((r: any) => r.offline_id) || []
  };
}

// Clear synced data from offline storage
async function clearSyncedData(syncedIds: string[]): Promise<void> {
  try {
    const db = await openSyncDB();
    const transaction = db.transaction(['pending_transactions'], 'readwrite');
    const store = transaction.objectStore('pending_transactions');

    for (const id of syncedIds) {
      store.delete(id);
    }

    await new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve(undefined);
      transaction.onerror = () => reject(transaction.error);
    });
  } catch (error) {
    console.error('Failed to clear synced data:', error);
  }
}

// Open IndexedDB for sync operations
async function openSyncDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('CashierSyncDB', 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;

      // Create object stores
      if (!db.objectStoreNames.contains('pending_transactions')) {
        const store = db.createObjectStore('pending_transactions', { keyPath: 'offline_id' });
        store.createIndex('timestamp', 'created_at');
      }

      if (!db.objectStoreNames.contains('sync_logs')) {
        const logStore = db.createObjectStore('sync_logs', { keyPath: 'id' });
        logStore.createIndex('status', 'status');
        logStore.createIndex('timestamp', 'created_at');
      }
    };
  });
}

// Notify all clients
async function notifyClients(message: any): Promise<void> {
  const clients = await self.clients.matchAll();
  clients.forEach(client => {
    client.postMessage(message);
  });
}

// Handle push notifications for sync reminders
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();

  if (data.type === 'SYNC_REMINDER') {
    event.waitUntil(
      self.registration.showNotification('Sync Pending', {
        body: data.message || 'You have offline data waiting to be synchronized',
        icon: '/android-chrome-192x192.png',
        badge: '/favicon.svg',
        tag: 'sync-reminder',
        actions: [
          {
            action: 'sync-now',
            title: 'Sync Now'
          },
          {
            action: 'dismiss',
            title: 'Dismiss'
          }
        ]
      })
    );
  }
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  if (event.action === 'sync-now') {
    event.waitUntil(
      (async () => {
        // Try to open app and trigger sync
        const clients = await self.clients.matchAll();
        if (clients.length > 0) {
          clients[0].focus();
          clients[0].postMessage({ type: 'TRIGGER_SYNC' });
        } else {
          // Open the app if no clients are open
          await self.clients.openWindow('/');
        }

        // Also try to sync in background
        await syncOfflineData();
      })()
    );
  }
});

// Message handling from main thread
self.addEventListener('message', (event) => {
  const { type, data } = event.data;

  switch (type) {
    case 'REGISTER_SYNC':
      // Register background sync
      self.registration.sync.register(SYNC_TAG).catch((error) => {
        console.error('Failed to register background sync:', error);
      });
      break;

    case 'FORCE_SYNC':
      // Force immediate sync
      event.waitUntil(syncOfflineData());
      break;

    case 'STORE_OFFLINE_TRANSACTION':
      // Store transaction for later sync
      event.waitUntil(storeOfflineTransaction(data));
      break;
  }
});

// Store offline transaction
async function storeOfflineTransaction(transactionData: any): Promise<void> {
  try {
    const db = await openSyncDB();
    const transaction = db.transaction(['pending_transactions'], 'readwrite');
    const store = transaction.objectStore('pending_transactions');

    // Add timestamp and ensure offline_id exists
    const dataToStore = {
      ...transactionData,
      offline_id: transactionData.offline_id || crypto.randomUUID(),
      created_at: transactionData.created_at || new Date().toISOString(),
      stored_at: new Date().toISOString()
    };

    store.put(dataToStore);

    await new Promise((resolve, reject) => {
      transaction.oncomplete = () => resolve(undefined);
      transaction.onerror = () => reject(transaction.error);
    });

    // Register for background sync
    await self.registration.sync.register(SYNC_TAG);

  } catch (error) {
    console.error('Failed to store offline transaction:', error);
    throw error;
  }
}

// Skip waiting and take control immediately when updated
self.addEventListener('install', () => {
  self.skipWaiting();
});

// Log service worker events for debugging
self.addEventListener('activate', (event) => {
  console.log('Service Worker activated');
});

console.log('Service Worker loaded with sync capabilities');
